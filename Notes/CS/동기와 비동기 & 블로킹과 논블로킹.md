# 동기/비동기, 블로킹/논블로킹

## 동기/비동기 & 블로킹/논블로킹 ?

처음 이걸 들었을 때 연관성을 있어보이지만 이게 뭐지? 라는 생각이 들었다.</br>
동기와 비동기, 블로킹과 논블로킹 이 두개는 서로 다른 차원에서 작업의 수행 방식을 설명하는 개념이다.

**동기/비동기**에서 중요한건 **작업에 대한 완료 여부**라고 할 수 있다.

작업 완료 여부를 신경쓰고 작업을 순차적으로 수행할지 아닌지에 대한 것으로 동기인지 비동기인지 정해진다.

그렇다면 **블로킹/논블로킹**은 뭘까?</br>
현재 작업이 Block(차단, 대기) 되는지에 따라 작업을 수행할 수 있는지에 대한 관점이다.

![동기와 비동기 요청, 응답](./%EB%8F%99%EA%B8%B0%EC%99%80%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%26%20%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC%20%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9/Untitled.png)

동기와 비동기 요청, 응답

하지만 개념의 차이는 명확하지만, 프로그래밍에서 혼용되어 사용된다.

대표적인 예로 JS의 setTimeout() 함수는 일반적으로 비동기 함수라고 부르지만 동시에 논블로킹 함수다.</br>
우리가 편의상 부르는 JS 비동기 함수는 사실 비동기 + 논블로킹 함수이다.

## 비동기는 성능을 향상시켜주는걸까?

우리가 아는 비동기 특징을 생각해보면 위에 말한 것 처럼 **작업에 대한 완료 여부**를 따지지 않기 때문에 I/O작업과 같은 느린 작업이 발생했을 때, 기다리지 않고 다른 작업을 처리하여 멀티 작업을 진행할 수 있게 되고 전반적인 시스템의 성능 향상에 도움을 줄 수 있게 된다!!

![동기와 비동기 처리 예시](./%EB%8F%99%EA%B8%B0%EC%99%80%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%26%20%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC%20%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9//Untitled%201.png)

그렇지만 작업에 대한 순서가 없기 때문에 문제가 발생했을 때 어디서 발생했는지 쉽게 찾지 못할 수 도 있습니다!~

## 그래서 블로킹/논블로킹이 뭔데!!

블로킹, 논블로킹은 단어에서 알 수 있듯이 다른 요청의 작업을 처리하기 위해 현재작업을 **block(차단, 대기) 하냐 안하냐의 유무**를 나타내는 **프로세스의 실행방식**이다!!

예를 들어, 파일을 읽는 작업이 있을 때 블로킹 방식이라면 파일을 다 읽을 때까지 대기하고,
논블로킹이라면 파일을 다 읽지 않아도 다른 작업을 할 수 있다!

![Untitled](./%EB%8F%99%EA%B8%B0%EC%99%80%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%26%20%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC%20%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9/Untitled%202.png)

### 논블로킹과 비동기 차이가 뭔데..?

그럼 여기서 의문인 것은
비동기랑 다른게 뭐지? 라는 생각이 들었다.

비동기는 출력 순서와 관련된 개념이라면
논블로킹이 병렬 실행과 관련된 개념이라고는 하는데 이해가 안된다. 뭔말인지 뿌엑

그래서 찾아보니 **제어권** 이라는 말이 있었다.

병렬 실행에서 Blocking 함수가 처리될 때에는 제어권을 가진 함수가 처리될 때까지 대기해야한다.

## 4가지 동기/비동기 + 블로킹/논블로킹 조합

### 1. **Sync-Blocking**

![Untitled](./%EB%8F%99%EA%B8%B0%EC%99%80%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%26%20%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC%20%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9//Untitled%203.png)

A함수는 B함수의 리턴값을 필요로한다 → **동기**

제어권을 B에게 넘겨주고 B가 실행을 완료하여 리턴값, 제어권을 돌려줄 때까지 기다린다. → **블로킹**

![Untitled](./%EB%8F%99%EA%B8%B0%EC%99%80%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%26%20%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC%20%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9//Untitled%204.png)

Sync-Blocking의 대표적인 예는 파일을 읽고 내용을 처리하는 로직이 있다. 파일을 읽어야 다음 작업을 처리할 수 있기 때문이다.

### 2. **Sync-Nonblokcing**

![Untitled](./%EB%8F%99%EA%B8%B0%EC%99%80%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%26%20%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC%20%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9/Untitled%205.png)

A 함수는 B 함수를 호출한다. 이 때 A함수는 B함수에게 제어권을 주지 않고, 자신의 코드를 계속 실행한다 → **논블로킹**

그런데 A 함수는 B함수의 리턴값이 필요하기 때문에 계속해서 B 함수에게 실행이 완료되었는지 확인한다 → **동기**

![Untitled](./%EB%8F%99%EA%B8%B0%EC%99%80%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%26%20%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC%20%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9/Untitled%206.png)

동기+논블로킹의 예로는 Java의 Thread객체를 통해 while문을 돌며 thread가 처리되어있는지 계속 확인하며, 처리 완료되면 다음 작업을 하는 것이 있다.

JS에서 비슷한 표현은 await를 키워드를 사용해 동기적으로 처리하는 Async/await 가 있다!

추가로 예를 들면 게임에서 맵을 이동할 때 맵 데이터를 모두 다운로드 해야한다. 그동안 화면에 로딩화면이 표현되는데 여기에는 로딩바가 채워지는 프로그램이 수행되고 있는다.  
즉, 제어권은 여전히 나한테 있는 상태로 끊임없이 맵 데이터가 다운로드 되었는지 확인하는 것이다!!!

**Sync Blocking** **VS** **Sync Non-Blocking**

일반적으로 동기 + 논블로킹이 동기 + 블로킹보다 효율적이다.

**Why?** <br/> 동기 + 논블로킹은 호출하는 함수가 제어권을 가지고 있어 다른 작업을 병렬적으로 수행할 수 있기 때문이다!
그말은 즉 동기 + 블로킹은 다른 작업을 수행할 수 없다는 말이다!!@#!@#@!!

### 3. **Async-Nonblocking**

비동기 논블로킹은 우리가 자주 사용하는 비동기 통신이다.

![Untitled](./%EB%8F%99%EA%B8%B0%EC%99%80%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%26%20%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC%20%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9/Untitled%207.png)

A함수는 B를 호출한다.

하지만 제어권은 넘기지 않고 있고 → **논블로킹**
B함수를 호출한 뒤에도 A는 자신의 코드를 계속 실행한다.

그리고 B함수를 호출할 때 **콜백함수**를 함께주는데 B함수는 자신의 작업이 끝나면 A가 준 콜백함수를 실행한다! → **\*비동기**

![Untitled](./%EB%8F%99%EA%B8%B0%EC%99%80%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%26%20%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC%20%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9/Untitled%208.png)

Async Nonblocking은 작업량이 많거나 시간이 오래 걸리는 작업을 해야할 때 적합나다.
대용량을 처리하거나 많은 요청을 처리하는 서비스에서 사용할 때 처리 성능을 향상시켜 전체 처리 시간을 줄일 수 있다.

### 4. **Async-blocking**

(다룰 일이 거의 없다.. 알아만 두자)

![Untitled](./%EB%8F%99%EA%B8%B0%EC%99%80%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%26%20%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC%20%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9/Untitled%209.png)

Async Blocking은 Sync Blocking과 큰 차이가 없다..</br>
A함수는 B함수의 리턴값에 신경쓰지않고, 콜백함수를 보낸다. → **비동기**

그런데 B함수의 리턴값에 신경쓰지는 않지만 A는 B에게 제어권을 넘긴다 → **블로킹** </br>
따라서 A함수는 B함수의 작업이 끝날 때까지 기다려야한다.

참고 : <br/>
https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC <br/>
https://velog.io/@nittre/%EB%B8%94%EB%A1%9C%ED%82%B9-Vs.-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0-Vs.-%EB%B9%84%EB%8F%99%EA%B8%B0
