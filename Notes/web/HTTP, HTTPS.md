# **HTTP, HTTPS**

## **HTTP와 HTTPS**

### **HTTP(Hypertext Transfer Protocol)**

**HTML 문서를 주고 받는 통신 규약**입니다.

우리가 인터넷에 접속해 다른 홈페이지에 방문하면 클라이언트와 서버가 통신을 하며 자료를 주고 받는데 이 때 서버가 클라이언트에게 HTML 자료를 전송할 때 HTTP 통신 규약을 사용합니다.

(주소 맨 앞에 있는 http)

### **HTTP의 문제**

단순하게 서버와 공개적인 정보를 주고 받기 위해서는 HTTP 통신도 아무 문제가 없지만 은행 거래나 아주 중요한 비밀번호를 주고 받을 경우 해커에 의해 정보가 노출될 문제가 있기 때문입니다

### **HTTPS(**Hypertext Transfer Protocol Secure)\*\*\*\*

위에서 언급한 HTTP의 보안적 문제로 HTTPS가 등장하게 됩니다. HTTP와 HTTPS를 통해 각각 통신을 수행하면 동일한 결과값을 받을 수 있습니다.

하지만 통신하는 과정에서 HTTPS는 전송 내용을 **암호화!** 시킵니다. 암호화의 장점은 **발신자와 수신자를 제외한 중간 매개체에서 통신 내용을 확인할 수 없는 것입니다!**

(주소 맨 앞에 있는 https)

## **HTTP와 HTTPS이 차이점**

차이는 간단합니다! HTTP를 암호화하면 HTTPS입니다.

그럼 이 암호화는 어떻게 진행될까요?

SSL(TLS) 인증을 통해 HTTPS 암호화를 진행하고 발신자, 수신자만 해당 암호를 해독하여 정보를 주고받을 수 있습니다.

## **SSL(Secure Socket Layer)**

암호화를 책임지는 SSL 인증서는 다음과 같이 동작합니다.

기존 HTTP는 클라이언트 ↔ 서버 통신을 진행할 때 두 당사자만 믿고 통신을 합니다.

하지만 HTTPS는 제 3자가 등장합니다.

즉 신뢰하는 다른 기관이 존재하고 해당 기관이 서버 또는 클라이언트에 SSL 인증서를 발급해 해당 당자사를 보증해 주는 것입니다.

이를 통해 우리는 접속할 사이트가 SSL 인증서를 통해 신뢰할 수 있는 사이트인지 알 수 있습니다.

전송되는 데이터를 암호화

![SSL 간단 설명](../../images/web/HTTP,%20HTTPS/SSL%20간단%20설명.png)

1. 클라이언트가 SSL계층으로 평문데이터를 전달
2. SSL 계층을 거치고 암호화된 http 메시지로 변환
3. 서버측 SSL 계층에 도착하면 원본 평문데이터로 변환
4. 평문데이터가 서버로 전달

**평문데이터?**

```html
POST /api/auth/login HTTP/1.1 Content-Type : application/json:charset=UTF-8 Content-Length : 60 HOST
: loaclhost:8080 { “email” : “abc@abc.com”, “password” : “123123123”, }
```

## **HTTPS 전환의 중요성**

### **HTTPS의 표준화**

HTTP를 사용할지 HTTPS를 사용할지 결정하기 보단 무조건 보안을 위해 HTTPS를 사용해야 합니다.

추가로 2021년 부터 대부분의 브라우저는 HTTP로 통신을 하는 웹사이트에서 경고 문구를 발생 시킵니다. 이 때문에 HTTP 통신을 사용해서 사이트에 방문하게 되면 경고 문구 때문에 바로 진입하지 못하게 됩니다.

### **웹사이트 HTTPS 전환 이유**

사업자로서 고객의 정보 보호를 보호해야 합니다.

사이트 진입시 HTTP 경고 문구가 발생하면 클라이언트가 접근을 꺼리기 때문에 유입이 낮아질 수 있습니다.

HTTPS 통신 웹사이트가 아닐 경우 검색 결과 노출에서 후순위로 밀릴 수 있습니다.

## **암호화, 복호화, 키 간단 정리**

### **암호화, 복호화, 키**

어떤 정보를 외부에 노출시키지 않기 위해 변형하는 것을 **암호화**라고 합니다.

반대로 암호화된 데이터를 원본으로 복원하는것을 **복호화**라고 합니다.

암호화와 복호화에서 데이터 변형을 위해 사용하는 것을 **키**라고 합니다.

이렇게 키를 사용하여 **암호화/복호화**하는 방식에는 **대칭키 방식**과 **공개키 방식**이 있고 두 방식 모두 **SSL 통신**에 사용되기 때문에 이해할 필요가 있습니다.

### **대칭키 방식**

**대칭키**는 동일한 키로 암호화, 복호화를 같이 할 수 있는 암호화 기법입니다.

암호화, 복호화를 위해 양쪽이 같은 키를 가져야 한다는 점에서 이 키를 **대칭키**라고 합니다.

![대칭키](../../images/web/HTTP,%20HTTPS/대칭키.png)

하지만 A, B 중 하나에서 대칭키가 탈취된다면 정보가 유출될 위험도 있습니다.

이를 막기 위해 나온 방식이 **공개키 방식**입니다!

### **공개키 방식**

**공개키**는 키가 2개 있습니다.

A키로 암호화하면 B로 복호화할 수 있고, B키로 암호화하면 A로 복호화 하는 방식입니다.

두개의 키 중 하나는 공개키, 하나는 비공개 키로 지정합니다.

![공개키](../../images/web/HTTP,%20HTTPS/공개키.png)

A는 B에게 공개키를 전달합니다.

B는 A의 공개키를 통해 정보를 암호화 한 후 A에게 전달합니다.

A에서는 비공개키를 이용해 전달 받은 정보를 복호화합니다.

**공개키 방식은 다음과 같이 응용할 수 있는데요**

![공개키 응용](../../images/web/HTTP,%20HTTPS/공개키%20응용.png)

A에서 **비공개키를 이용해 정보를 암호화** 한 뒤 **공개키와 함께** 암호화된 정보를 **B에 전달**합니다.

하지만 이런 방식은 중간에 공개키, 암호화된 정보를 탈취 당하면 정보를 노출당할 수 도 있습니다.

**하지만 SSL은 이 응용방식을 사용합니다.**

그 이유는 공개키 응용 방식이 데이터 보호 목적이 아니기 때문입니다!

A에서 전달한 정보를 A의 공개키로 복호화한다면 정보가 A에서 전달한 정보임을 신뢰할 수 있습니다.

즉! 공개키가 정보를 전달한 사람의 신원을 보장해주는 것입니다! 이것을 **전자 서명**이라고 하고 **SSL 통신**에서 서버의 신원 확인을 위해 사용합니다.

## **인증서 발급**

### **인증서 발급 과정과 원리**

서버에서 HTTPS 프로토콜 사용을 위해 SSL 인증서를 발급받는 과정 , CA는 인증기관

1. (서버) 서버의 공개키(public key) 비밀키 (private key)를 생성합니다.
2. (서버 → CA) 인증서 발급을 위해 서버는 CA에 **1번에서 생성한 공개키**, **서버의 정보들**을 전달합니다.
3. (CA) 2번에서 서버로 부터 받은 정보들을 담아 SSL 인증서를 발급합니다!
4. **(CA) 3번에서 만든 인증서를 암호화 하기 위해, CA의 공개키(public key) 와 비밀키(private key)를 생성하고 CA의 비밀키를 이용해 SSL 인증서를 암호화합니다!**
5. (CA → Server) 4번에서 암호화한 SSL인증서를 다시 서버에 전달!! (SSL 인증서 발급 완료)

이렇게 발급받은 SSL 인증서에 대한 정보**(4번에서 생성한 CA의 공개키 정보까지)**는 모두 공개되어 있습니다! 브라우저에서 모두 확인 가능 👇

![브라우저에 저장된 정보](../../images/web/HTTP,%20HTTPS/브라우저에%20저장된%20정보.png)

## **SSL 통신 과정**

### **SSL 통신 과정 간단 정리**

SSL 통신 과정은 공개키 방식으로 이루어집니다.(공개키 응용 방식은 밑에 있어요!)

![SSL 통신](../../images/web/HTTP,%20HTTPS/SSL%20통신.png)

**클라이언트**와 **서버**는 각각 비공개키, 공개키를 가지고 자신의 공개키를 서로에게 전달합니다.

이 때 서로의 공개키는 비공개키가 없다면 복호화 할 수 없기 때문에 보안에 취약점이 없습니다.

그리고 나서 **클라이언트**는 **서버의 공개키**로 정보를 **암호화해서 전달**하고 **서버**는 전달 받은 정보를 **자신의 비공개키**로 **복호화**한 뒤 정보를 처리합니다.

마지막으로 **서버는** **클라이언트의 공개키로** 응답해줄 정보를 **암호화**해서 다시 **클라이언트에게 전달**합니다.

하지만 위와 같은 공개키 방식은 컴퓨팅 파워를 많이 써 성능 측면에서 비효율적입니다.

**따라서! SSL 통신은 공개키 방식 + 대칭 키 방식을 사용해 보안, 성능 두 가지를 보장합니다.**

### **SSL 통신 과정**

**HandShake → 통신 → 통신 종료**

이는 SSL 통신의 세가지 과정입니다.

### **1. HandShake**

SSL 통신은 데이터를 주고 받기 전!<br/>
**어떻게 데이터를 암호화할지, 믿을 만한 서버인지**에 대해 확인합니다.

1.  **클라이언트가 서버에 접속**합니다.
    이 단계를 `Client Hello`라고 하고, 이 단계에서 아래와 같은 정보를 주고 받습니다. - 클라이언트 측에서 생성한 랜덤 데이터 - 클라이언트가 지원하는 암호화 방식들 ⇒ 클라이언트가 가능한 암호화 방식을 서버에 알려주기 위해서
2.  서버는 `Client Hello`에 대한 응답으로 `Server Hello`를 합니다. 이 단계에서 주고받는 정보는 아래와 같습니다.
    - 서버 측에서 생성한 랜덤 데이터
    - 서버가 선택한 클라이언트의 암호화 방식 ⇒ 선택한 암호화 방식을 클라이언트에게 알려주기 위해
    - 인증서
3.  **클라이언트는 서버의 인증서가 CA에 의해 발급된 것인지 확인**합니다.
    이 때 **클라이언트에 내장된 CA리스트와 CA의 공개키를 사용해 인증서를 복호화** 합니다!

    > 위에서 말했던 **공개키 응용 방식을 활용**!!
    > 클라이언트(브라우저)는 CA종류와 CA의 공개키가 내장되어 있습니다! 이걸 통해 신뢰할 수 있는지 확인!!! >
    > 성공적으로 복호화가 됐다면 서버가 전달한 인증서가 CA의 개인키로 암호화된 문서임이 보증된 것이고 **올바른 서버임을 신뢰 할 수 있게 됩니다!**

    서버를 신뢰할 수 있으므로 클라이언트는 **서버가 생성한 랜덤 데이터, 클라이언트가 생성한 랜덤 데이터**를 조합하여 `pre master secret`이라는 **key**를 생성하고 `pre master secret key`는 **대칭키 암호화**에 사용됩니다.

    **클라이언트**에서 `pre master secret key`로 **대칭키 암호화를 진행**할 것인데 `pre master secret key`로 암호화된 정보를 **서버에서** 복호화하려면 `**pre master secret key` 를 알아야 합니다.\*\*

    그렇다면 서버도 `pre master secret key`를 알아야 하는데 클라이언트에서 서버로 `pre master secret key`를 그대로 전달하면 중간에 탈취 당해 악용될 수도 있습니다.

    그래서 이 때 사용하는 방법이 **공개키 방식입니다.**

    **서버의 공개키(서버가 전달해준 인증서 내부에 있는 정보)** 로 `pre master secret key`를 암호화해서 **서버**로 전송합니다!

4.  **서버**는 **자신의 비공개키**를 통해 `pre master secret key`를 **복호화합니다.**

    이를 통해 **클라이언트는 서버와 같은 `pre master secret key`를 가지고** 일련의 과정을 통해 `pre master secret`을 `master secret`이라는 `session key`를 생성합니다.

    `master secret`은 실제로 클라이언트-서버가 주고받는 데이터를 암호화/복호화 하는데 사용합니다.

5.  클라이언트, 서버는 **HandShake**가 종료되었음을 서로에게 알립니다.

### **2. 통신**

이제 `master secret`을 통해 클라이언트-서버는 데이터를 암호화/복호화 하면서 주고 받습니다.

### **3. 통신 종료**

데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려주고 사용한 대칭키인 `master secret`은 폐기합니다.
